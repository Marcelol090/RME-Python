description: "Padrões de desenvolvimento C++ para OpenTibia (TFS Legacy vs Canary Modern)" globs: "src//*.cpp, src//.h, src/**/.hpp, src/CMakeLists.txt" alwaysApply: falseOpenTibia C++ Engine GuidelinesEsta regra orienta a implementação em C++, distinguindo entre Legacy (TFS 1.x) e Modern (Canary/OTServBR).1. Detecção de ContextoAnalise o código existente ou o CMakeLists.txt para determinar o padrão:FeatureLegacy (TFS 1.x)Modern (Canary/OTServBR)PadrãoC++11 / C++14 / C++17C++20 (Mandatório)Formataçãosprintf, std::ostringstreamstd::format, fmt::printPonteirosRaw (*), delete manualstd::shared_ptr, std::unique_ptrLoopsIterators (it->second)std::ranges, for (auto&)2. Gerenciamento de MemóriaCanary (Modern)Smart Pointers: NUNCA use new ou delete explícitos.Alocação: Use std::make_shared<T>() ou std::make_unique<T>().Referências Fracas: Use std::weak_ptr para quebrar referências cíclicas (ex: Party ↔ Player).TFS (Legacy)Null Safety: Prefira nullptr ao invés de NULL.Lifecycle: Respeite o gerenciamento manual nos destrutores (~ClassName).3. Padrões de PerformanceOtimização de LoopsEvite cópias desnecessárias em hot paths (loops de monstros/jogadores).// BAD (Cria cópia do objeto)
for (auto creature : creatureList) { ... }

// GOOD (Referência constante)
for (const auto& creature : creatureList) { ... }
Filtering (Canary Only)Use Views para filtrar listas sem alocação temporária:// Modern C++20 Approach
auto monsters = creatures | std::views::filter([](const auto& c){ return c->getMonster(); });
4. SegurançaNetwork: Nunca leia de NetworkMessage sem verificar msg.isEOF() e limites de tamanho.Crash Fix: Verifique creature->isRemoved() antes de executar eventos agendados (Scheduler).